/**
 * Wision55
 * API per l'utilizzo dei servizi della piattaforma Wision55
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class NegozioApi {

    protected basePath = 'https://wision55.mywatson.it/api';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Aggiorna un Pos
     * @summary Metodo che permette di aggiornare un Pos
     * @param id id del pos
     * @param pos Il pos da aggiornare
     */
    public aggiornaPos(id: number, pos: models.PosVO, extraHttpRequestParams?: any): Observable<{}> {
        return this.aggiornaPosWithHttpInfo(id, pos, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Annulla una operazione
     * @summary Metodo che annulla una operazione
     * @param id id operazione
     */
    public annullaOperazione(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.annullaOperazioneWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna un JSON contenente il token
     * @summary Metodo di autenticazione mediante username e password
     * @param authRequest Username e password inseriti al login
     */
    public autorizza(authRequest: models.AuthRequest, extraHttpRequestParams?: any): Observable<models.AuthResponse> {
        return this.autorizzaWithHttpInfo(authRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Conferma operazione
     * @summary Metodo che conferma una operazione
     * @param id id operazione
     * @param confermaOperazione Conferma operazione
     */
    public confermaOperazione(id: number, confermaOperazione?: models.ConfermaOperazioneVO, extraHttpRequestParams?: any): Observable<{}> {
        return this.confermaOperazioneWithHttpInfo(id, confermaOperazione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Converte da euro a wkey e viceversa
     * @summary Metodo che converte da euro a wkey e viceversa
     */
    public conversioneEuroWkey(extraHttpRequestParams?: any): Observable<models.InfoVO> {
        return this.conversioneEuroWkeyWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea una operazione
     * @summary Metodo che crea una operazione
     * @param richiestaOperazione La richiesta operazione
     */
    public creaOperazione(richiestaOperazione?: models.RichiestaOperazioneVO, extraHttpRequestParams?: any): Observable<models.RispostaOperazioneVO> {
        return this.creaOperazioneWithHttpInfo(richiestaOperazione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea un Pos
     * @summary Metodo che permette di creare un Pos
     * @param pos Il pos da creare
     */
    public creaPos(pos: models.PosVO, extraHttpRequestParams?: any): Observable<models.PosVO> {
        return this.creaPosWithHttpInfo(pos, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * disattiva un Pos
     * @summary Metodo che disattiva un Pos
     * @param id id del pos
     */
    public disattivaPos(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.disattivaPosWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista dei negozi (size = 0 lista completa)
     * @summary Metodo che ritorna la lista dei negozi
     * @param start start del paginatore
     * @param size size del paginatore
     * @param search stringa di ricerca
     */
    public findNegozi(start?: number, size?: number, search?: string, extraHttpRequestParams?: any): Observable<Array<models.NegozioVO>> {
        return this.findNegoziWithHttpInfo(start, size, search, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista dei pos
     * @summary Metodo che ritorna la lista dei pos
     * @param start start del paginatore
     * @param size size del paginatore
     * @param negozioId id del negozio
     * @param attivo stato del pos (&#39;true&#39;,&#39;false&#39; vuoto &#x3D; torna tutti)
     */
    public findPos(start?: number, size?: number, negozioId?: number, attivo?: string, extraHttpRequestParams?: any): Observable<Array<models.PosVO>> {
        return this.findPosWithHttpInfo(start, size, negozioId, attivo, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista delle transazioni (size = 0 lista completa)
     * @summary Metodo che ritorna la lista di transazioni
     * @param start start del paginatore
     * @param size size del paginatore
     * @param posId id del pos da cui Ã¨ stata eseguita l&#39;operazione
     * @param negozioId id del negozio che ha eseguito l&#39;operazione
     * @param query stringa di ricerca all&#39;interno della descrizione
     * @param clienteId id del cliente che ha fatto l&#39;acquisto
     */
    public findTransazioni(start?: number, size?: number, posId?: number, negozioId?: number, query?: string, clienteId?: number, extraHttpRequestParams?: any): Observable<Array<models.TransazioneVO>> {
        return this.findTransazioniWithHttpInfo(start, size, posId, negozioId, query, clienteId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna il dettaglio di una carta e del cliente per effettuare la transazione
     * @summary Metodo che ritorna i dettagli di una carta e del cliente per effettuare la transazione
     * @param codice codice della carta
     */
    public getInfoCartaByCodice(codice: string, extraHttpRequestParams?: any): Observable<models.InfoCardVO> {
        return this.getInfoCartaByCodiceWithHttpInfo(codice, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna il dettaglio di un negozio
     * @summary Metodo che ritorna i dettagli di un negozio a partire dall'id
     * @param id id del negozio
     */
    public getNegozioById(id: number, extraHttpRequestParams?: any): Observable<models.NegozioVO> {
        return this.getNegozioByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna un Pos
     * @summary Metodo che ritorna un Pos
     * @param id id del pos
     */
    public getPostById(id: number, extraHttpRequestParams?: any): Observable<models.PosVO> {
        return this.getPostByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna una transazione
     * @summary Metodo che ritorna una transazione
     * @param id id della transazione
     */
    public getTransazioneById(id: number, extraHttpRequestParams?: any): Observable<models.TransazioneVO> {
        return this.getTransazioneByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Metodo che permette di aggiornare un Pos
     * Aggiorna un Pos
     * @param id id del pos
     * @param pos Il pos da aggiornare
     */
    public aggiornaPosWithHttpInfo(id: number, pos: models.PosVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaPos.');
        }
        // verify required parameter 'pos' is not null or undefined
        if (pos === null || pos === undefined) {
            throw new Error('Required parameter pos was null or undefined when calling aggiornaPos.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: pos == null ? '' : JSON.stringify(pos), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che annulla una operazione
     * Annulla una operazione
     * @param id id operazione
     */
    public annullaOperazioneWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling annullaOperazione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo di autenticazione mediante username e password
     * Ritorna un JSON contenente il token
     * @param authRequest Username e password inseriti al login
     */
    public autorizzaWithHttpInfo(authRequest: models.AuthRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/auth';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'authRequest' is not null or undefined
        if (authRequest === null || authRequest === undefined) {
            throw new Error('Required parameter authRequest was null or undefined when calling autorizza.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: authRequest == null ? '' : JSON.stringify(authRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che conferma una operazione
     * Conferma operazione
     * @param id id operazione
     * @param confermaOperazione Conferma operazione
     */
    public confermaOperazioneWithHttpInfo(id: number, confermaOperazione?: models.ConfermaOperazioneVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling confermaOperazione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: confermaOperazione == null ? '' : JSON.stringify(confermaOperazione), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che converte da euro a wkey e viceversa
     * Converte da euro a wkey e viceversa
     */
    public conversioneEuroWkeyWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/info';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che crea una operazione
     * Crea una operazione
     * @param richiestaOperazione La richiesta operazione
     */
    public creaOperazioneWithHttpInfo(richiestaOperazione?: models.RichiestaOperazioneVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: richiestaOperazione == null ? '' : JSON.stringify(richiestaOperazione), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di creare un Pos
     * Crea un Pos
     * @param pos Il pos da creare
     */
    public creaPosWithHttpInfo(pos: models.PosVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pos' is not null or undefined
        if (pos === null || pos === undefined) {
            throw new Error('Required parameter pos was null or undefined when calling creaPos.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: pos == null ? '' : JSON.stringify(pos), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che disattiva un Pos
     * disattiva un Pos
     * @param id id del pos
     */
    public disattivaPosWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disattivaPos.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista dei negozi
     * Ritorna la lista dei negozi (size &#x3D; 0 lista completa)
     * @param start start del paginatore
     * @param size size del paginatore
     * @param search stringa di ricerca
     */
    public findNegoziWithHttpInfo(start?: number, size?: number, search?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (search !== undefined) {
            queryParameters.set('search', <any>search);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista dei pos
     * Ritorna la lista dei pos
     * @param start start del paginatore
     * @param size size del paginatore
     * @param negozioId id del negozio
     * @param attivo stato del pos (&#39;true&#39;,&#39;false&#39; vuoto &#x3D; torna tutti)
     */
    public findPosWithHttpInfo(start?: number, size?: number, negozioId?: number, attivo?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (negozioId !== undefined) {
            queryParameters.set('negozio_id', <any>negozioId);
        }

        if (attivo !== undefined) {
            queryParameters.set('attivo', <any>attivo);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista di transazioni
     * Ritorna la lista delle transazioni (size &#x3D; 0 lista completa)
     * @param start start del paginatore
     * @param size size del paginatore
     * @param posId id del pos da cui Ã¨ stata eseguita l&#39;operazione
     * @param negozioId id del negozio che ha eseguito l&#39;operazione
     * @param query stringa di ricerca all&#39;interno della descrizione
     * @param clienteId id del cliente che ha fatto l&#39;acquisto
     */
    public findTransazioniWithHttpInfo(start?: number, size?: number, posId?: number, negozioId?: number, query?: string, clienteId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (posId !== undefined) {
            queryParameters.set('pos_id', <any>posId);
        }

        if (negozioId !== undefined) {
            queryParameters.set('negozio_id', <any>negozioId);
        }

        if (query !== undefined) {
            queryParameters.set('query', <any>query);
        }

        if (clienteId !== undefined) {
            queryParameters.set('cliente_id', <any>clienteId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna i dettagli di una carta e del cliente per effettuare la transazione
     * Ritorna il dettaglio di una carta e del cliente per effettuare la transazione
     * @param codice codice della carta
     */
    public getInfoCartaByCodiceWithHttpInfo(codice: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/infocard/${codice}'
                    .replace('${' + 'codice' + '}', String(codice));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'codice' is not null or undefined
        if (codice === null || codice === undefined) {
            throw new Error('Required parameter codice was null or undefined when calling getInfoCartaByCodice.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna i dettagli di un negozio a partire dall&#39;id
     * Ritorna il dettaglio di un negozio
     * @param id id del negozio
     */
    public getNegozioByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getNegozioById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna un Pos
     * Ritorna un Pos
     * @param id id del pos
     */
    public getPostByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPostById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna una transazione
     * Ritorna una transazione
     * @param id id della transazione
     */
    public getTransazioneByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransazioneById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}

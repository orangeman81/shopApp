/**
 * Wision55
 * API per l'utilizzo dei servizi della piattaforma Wision55
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class WisionApi {

    protected basePath = 'https://wision55.mywatson.it/api';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Aggiorna i dati di una carta
     * @summary Metodo che aggiorna i dati di una carta
     * @param id id della carta
     * @param card La carta da creare
     */
    public aggiornaCarta(id: number, card?: models.CardVO, extraHttpRequestParams?: any): Observable<models.CardVO> {
        return this.aggiornaCartaWithHttpInfo(id, card, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiorna il cashback per quella categoria associata a quel negozio
     * @summary Metodo che aggiorna il cashback per quella categoria associata a quel negozio
     * @param id id di CashbackNegozioCategoria
     * @param cashbackNegozioCategoria Il cashbackNegozioCategoria da aggiornare
     */
    public aggiornaCashbackNegozioCategoria(id: number, cashbackNegozioCategoria?: models.CashbackNegozioCategoriaVO, extraHttpRequestParams?: any): Observable<models.CashbackNegozioCategoriaVO> {
        return this.aggiornaCashbackNegozioCategoriaWithHttpInfo(id, cashbackNegozioCategoria, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiorna una categoria
     * @summary Metodo che aggiorna una categoria
     * @param id id della categoria
     * @param categoria La categoria da aggiornare
     */
    public aggiornaCategoria(id: number, categoria?: models.CategoriaVO, extraHttpRequestParams?: any): Observable<models.CategoriaVO> {
        return this.aggiornaCategoriaWithHttpInfo(id, categoria, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiorna un cliente
     * @summary Metodo che aggiorna un cliente
     * @param id id del cliente
     * @param cliente Il cliente da aggiornare
     */
    public aggiornaCliente(id: number, cliente?: models.ClienteVO, extraHttpRequestParams?: any): Observable<models.ClienteVO> {
        return this.aggiornaClienteWithHttpInfo(id, cliente, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * aggiorna un negozio
     * @summary Metodo che aggiorna un negozio
     * @param id id del negozio
     * @param negozio Il negozio aggiornare
     */
    public aggiornaNegozio(id: number, negozio: models.NegozioVO, extraHttpRequestParams?: any): Observable<{}> {
        return this.aggiornaNegozioWithHttpInfo(id, negozio, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiorna un Pos
     * @summary Metodo che permette di aggiornare un Pos
     * @param id id del pos
     * @param pos Il pos da aggiornare
     */
    public aggiornaPos(id: number, pos: models.PosVO, extraHttpRequestParams?: any): Observable<{}> {
        return this.aggiornaPosWithHttpInfo(id, pos, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiorna una promozione
     * @summary Metodo che aggiorna una promozione
     * @param id id della promozione
     * @param promozione La promozione da aggiornare
     */
    public aggiornaPromozione(id: number, promozione?: models.PromozioneVO, extraHttpRequestParams?: any): Observable<models.PromozioneVO> {
        return this.aggiornaPromozioneWithHttpInfo(id, promozione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Aggiunge un negozio
     * @summary Metodo che aggiunge un negozio
     * @param negozio Il negozio da creare
     */
    public aggiungiNegozio(negozio?: models.NegozioVO, extraHttpRequestParams?: any): Observable<models.NegozioVO> {
        return this.aggiungiNegozioWithHttpInfo(negozio, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Annulla una operazione
     * @summary Metodo che annulla una operazione
     * @param id id operazione
     */
    public annullaOperazione(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.annullaOperazioneWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna un JSON contenente il token
     * @summary Metodo di autenticazione mediante username e password
     * @param authRequest Username e password inseriti al login
     */
    public autorizza(authRequest: models.AuthRequest, extraHttpRequestParams?: any): Observable<models.AuthResponse> {
        return this.autorizzaWithHttpInfo(authRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Conferma operazione
     * @summary Metodo che conferma una operazione
     * @param id id operazione
     * @param confermaOperazione Conferma operazione
     */
    public confermaOperazione(id: number, confermaOperazione?: models.ConfermaOperazioneVO, extraHttpRequestParams?: any): Observable<{}> {
        return this.confermaOperazioneWithHttpInfo(id, confermaOperazione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Converte da euro a wkey e viceversa
     * @summary Metodo che converte da euro a wkey e viceversa
     */
    public conversioneEuroWkey(extraHttpRequestParams?: any): Observable<models.InfoVO> {
        return this.conversioneEuroWkeyWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea un cashback per quella categoria associata a quel negozio
     * @summary Metodo che permette di creare un cashback per quella categoria associata a quel negozio
     * @param cashbackNegozioCategoria Il cashbackNegozioCategoria da creare
     */
    public creaCashbackNegozioCategoria(cashbackNegozioCategoria: models.CashbackNegozioCategoriaVO, extraHttpRequestParams?: any): Observable<models.CashbackNegozioCategoriaVO> {
        return this.creaCashbackNegozioCategoriaWithHttpInfo(cashbackNegozioCategoria, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea una categoria
     * @summary Metodo che permette di creare una categoria
     * @param categoria La categoria da creare
     */
    public creaCategoria(categoria: models.CategoriaVO, extraHttpRequestParams?: any): Observable<models.CategoriaVO> {
        return this.creaCategoriaWithHttpInfo(categoria, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea una operazione
     * @summary Metodo che crea una operazione
     * @param richiestaOperazione La richiesta operazione
     */
    public creaOperazione(richiestaOperazione?: models.RichiestaOperazioneVO, extraHttpRequestParams?: any): Observable<models.RispostaOperazioneVO> {
        return this.creaOperazioneWithHttpInfo(richiestaOperazione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea un Pos
     * @summary Metodo che permette di creare un Pos
     * @param pos Il pos da creare
     */
    public creaPos(pos: models.PosVO, extraHttpRequestParams?: any): Observable<models.PosVO> {
        return this.creaPosWithHttpInfo(pos, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Crea una promozione
     * @summary Metodo che permette di creare una promozione
     * @param promozione La promozione da creare
     */
    public creaPromozione(promozione: models.PromozioneVO, extraHttpRequestParams?: any): Observable<models.PromozioneVO> {
        return this.creaPromozioneWithHttpInfo(promozione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Disabilita una carta
     * @summary Metodo che disabilita una carta
     * @param id id della carta
     */
    public disabilitaCarta(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.disabilitaCartaWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Disabilita un cliente
     * @summary Metodo che disabilita un cliente
     * @param id id del cliente
     */
    public disabilitaCliente(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.disabilitaClienteWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Disabilita un negozio
     * @summary Metodo che disabilita un negozio
     * @param id id del negozio
     */
    public disabilitaNegozio(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.disabilitaNegozioWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Disabilita una promozione
     * @summary Metodo che disabilita una promozione
     * @param id id della promozione
     */
    public disabilitaPromozione(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.disabilitaPromozioneWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * disattiva un Pos
     * @summary Metodo che disattiva un Pos
     * @param id id del pos
     */
    public disattivaPos(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.disattivaPosWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * elimina il cashback di quel negozio per quella categoria
     * @summary Metodo che elimina il cashback di quel negozio per quella categoria
     * @param id id di CashbackNegozioCategoria
     */
    public eliminaCashbackNegozioCategoria(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.eliminaCashbackNegozioCategoriaWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * elimina una categoria
     * @summary Metodo che elimina una categoria
     * @param id id della categoria
     */
    public eliminaCategoria(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.eliminaCategoriaWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista di carte (size = 0 lista completa)
     * @summary Metodo che ritorna la lista di carte
     * @param start start del paginatore
     * @param size size del paginatore
     * @param clienteId id del cliente
     * @param codiceCard codice della carta
     */
    public findCarte(start?: number, size?: number, clienteId?: number, codiceCard?: string, extraHttpRequestParams?: any): Observable<Array<models.CardVO>> {
        return this.findCarteWithHttpInfo(start, size, clienteId, codiceCard, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista delle categoria con il relativo cashback associate a quel negozio
     * @summary Metodo che ritorna la lista delle categoria con il relativo cashback associate a quel negozio
     * @param negozioId id del negozio
     */
    public findCashbackNegozioCategoria(negozioId?: number, extraHttpRequestParams?: any): Observable<Array<models.CashbackNegozioCategoriaVO>> {
        return this.findCashbackNegozioCategoriaWithHttpInfo(negozioId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista delle categorie
     * @summary Metodo che ritorna la lista delle categorie
     * @param descrizione descrizione della categoria
     */
    public findCategorie(descrizione?: string, extraHttpRequestParams?: any): Observable<Array<models.CategoriaVO>> {
        return this.findCategorieWithHttpInfo(descrizione, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Torna la lista dei clienti
     * @summary Metodo che ritorna la lista dei clienti
     * @param start start del paginatore
     * @param size size del paginatore
     * @param search stringa di ricerca
     */
    public findCliente(start?: number, size?: number, search?: string, extraHttpRequestParams?: any): Observable<Array<models.ClienteVO>> {
        return this.findClienteWithHttpInfo(start, size, search, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista dei negozi (size = 0 lista completa)
     * @summary Metodo che ritorna la lista dei negozi
     * @param start start del paginatore
     * @param size size del paginatore
     * @param search stringa di ricerca
     */
    public findNegozi(start?: number, size?: number, search?: string, extraHttpRequestParams?: any): Observable<Array<models.NegozioVO>> {
        return this.findNegoziWithHttpInfo(start, size, search, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista dei pos
     * @summary Metodo che ritorna la lista dei pos
     * @param start start del paginatore
     * @param size size del paginatore
     * @param negozioId id del negozio
     * @param attivo stato del pos (&#39;true&#39;,&#39;false&#39; vuoto &#x3D; torna tutti)
     */
    public findPos(start?: number, size?: number, negozioId?: number, attivo?: string, extraHttpRequestParams?: any): Observable<Array<models.PosVO>> {
        return this.findPosWithHttpInfo(start, size, negozioId, attivo, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista delle promozioni
     * @summary Metodo che ritorna la lista delle promozioni
     * @param negozioId id del negozio. Solo per utente&#x3D;wision. Se negozio_id&#x3D;null torna tutte le promozioni
     */
    public findPromozioni(negozioId?: number, extraHttpRequestParams?: any): Observable<Array<models.PromozioneVO>> {
        return this.findPromozioniWithHttpInfo(negozioId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna la lista delle transazioni (size = 0 lista completa)
     * @summary Metodo che ritorna la lista di transazioni
     * @param start start del paginatore
     * @param size size del paginatore
     * @param posId id del pos da cui Ã¨ stata eseguita l&#39;operazione
     * @param negozioId id del negozio che ha eseguito l&#39;operazione
     * @param query stringa di ricerca all&#39;interno della descrizione
     * @param clienteId id del cliente che ha fatto l&#39;acquisto
     */
    public findTransazioni(start?: number, size?: number, posId?: number, negozioId?: number, query?: string, clienteId?: number, extraHttpRequestParams?: any): Observable<Array<models.TransazioneVO>> {
        return this.findTransazioniWithHttpInfo(start, size, posId, negozioId, query, clienteId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna i dati di una carta
     * @summary Metodo che ritorna i dati di una carta
     * @param id id della carta
     */
    public getCartaById(id: number, extraHttpRequestParams?: any): Observable<models.CardVO> {
        return this.getCartaByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna un cliente
     * @summary Metodo che ritorna un cliente
     * @param id id del cliente
     */
    public getClienteById(id: number, extraHttpRequestParams?: any): Observable<models.ClienteVO> {
        return this.getClienteByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna il dettaglio di una carta e del cliente per effettuare la transazione
     * @summary Metodo che ritorna i dettagli di una carta e del cliente per effettuare la transazione
     * @param codice codice della carta
     */
    public getInfoCartaByCodice(codice: string, extraHttpRequestParams?: any): Observable<models.InfoCardVO> {
        return this.getInfoCartaByCodiceWithHttpInfo(codice, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna il dettaglio di un negozio
     * @summary Metodo che ritorna i dettagli di un negozio a partire dall'id
     * @param id id del negozio
     */
    public getNegozioById(id: number, extraHttpRequestParams?: any): Observable<models.NegozioVO> {
        return this.getNegozioByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna un Pos
     * @summary Metodo che ritorna un Pos
     * @param id id del pos
     */
    public getPostById(id: number, extraHttpRequestParams?: any): Observable<models.PosVO> {
        return this.getPostByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Ritorna una transazione
     * @summary Metodo che ritorna una transazione
     * @param id id della transazione
     */
    public getTransazioneById(id: number, extraHttpRequestParams?: any): Observable<models.TransazioneVO> {
        return this.getTransazioneByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Inserisci una carta
     * @summary Metodo che permette di inserire una carta
     * @param card La carta da creare
     */
    public inserisciCarta(card: models.CardVO, extraHttpRequestParams?: any): Observable<models.CardVO> {
        return this.inserisciCartaWithHttpInfo(card, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Inserisce un cliente
     * @summary Metodo che permette di inserire un cliente
     * @param cliente Il cliente da inserire
     */
    public inserisciCliente(cliente?: models.ClienteVO, extraHttpRequestParams?: any): Observable<models.ClienteVO> {
        return this.inserisciClienteWithHttpInfo(cliente, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Metodo che aggiorna i dati di una carta
     * Aggiorna i dati di una carta
     * @param id id della carta
     * @param card La carta da creare
     */
    public aggiornaCartaWithHttpInfo(id: number, card?: models.CardVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/card/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaCarta.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: card == null ? '' : JSON.stringify(card), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che aggiorna il cashback per quella categoria associata a quel negozio
     * Aggiorna il cashback per quella categoria associata a quel negozio
     * @param id id di CashbackNegozioCategoria
     * @param cashbackNegozioCategoria Il cashbackNegozioCategoria da aggiornare
     */
    public aggiornaCashbackNegozioCategoriaWithHttpInfo(id: number, cashbackNegozioCategoria?: models.CashbackNegozioCategoriaVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cashback_negozio_categoria/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaCashbackNegozioCategoria.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: cashbackNegozioCategoria == null ? '' : JSON.stringify(cashbackNegozioCategoria), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che aggiorna una categoria
     * Aggiorna una categoria
     * @param id id della categoria
     * @param categoria La categoria da aggiornare
     */
    public aggiornaCategoriaWithHttpInfo(id: number, categoria?: models.CategoriaVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/categoria/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaCategoria.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: categoria == null ? '' : JSON.stringify(categoria), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che aggiorna un cliente
     * Aggiorna un cliente
     * @param id id del cliente
     * @param cliente Il cliente da aggiornare
     */
    public aggiornaClienteWithHttpInfo(id: number, cliente?: models.ClienteVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cliente/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaCliente.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: cliente == null ? '' : JSON.stringify(cliente), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che aggiorna un negozio
     * aggiorna un negozio
     * @param id id del negozio
     * @param negozio Il negozio aggiornare
     */
    public aggiornaNegozioWithHttpInfo(id: number, negozio: models.NegozioVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaNegozio.');
        }
        // verify required parameter 'negozio' is not null or undefined
        if (negozio === null || negozio === undefined) {
            throw new Error('Required parameter negozio was null or undefined when calling aggiornaNegozio.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: negozio == null ? '' : JSON.stringify(negozio), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di aggiornare un Pos
     * Aggiorna un Pos
     * @param id id del pos
     * @param pos Il pos da aggiornare
     */
    public aggiornaPosWithHttpInfo(id: number, pos: models.PosVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaPos.');
        }
        // verify required parameter 'pos' is not null or undefined
        if (pos === null || pos === undefined) {
            throw new Error('Required parameter pos was null or undefined when calling aggiornaPos.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: pos == null ? '' : JSON.stringify(pos), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che aggiorna una promozione
     * Aggiorna una promozione
     * @param id id della promozione
     * @param promozione La promozione da aggiornare
     */
    public aggiornaPromozioneWithHttpInfo(id: number, promozione?: models.PromozioneVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/promozione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling aggiornaPromozione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: promozione == null ? '' : JSON.stringify(promozione), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che aggiunge un negozio
     * Aggiunge un negozio
     * @param negozio Il negozio da creare
     */
    public aggiungiNegozioWithHttpInfo(negozio?: models.NegozioVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: negozio == null ? '' : JSON.stringify(negozio), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che annulla una operazione
     * Annulla una operazione
     * @param id id operazione
     */
    public annullaOperazioneWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling annullaOperazione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo di autenticazione mediante username e password
     * Ritorna un JSON contenente il token
     * @param authRequest Username e password inseriti al login
     */
    public autorizzaWithHttpInfo(authRequest: models.AuthRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/auth';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'authRequest' is not null or undefined
        if (authRequest === null || authRequest === undefined) {
            throw new Error('Required parameter authRequest was null or undefined when calling autorizza.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: authRequest == null ? '' : JSON.stringify(authRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che conferma una operazione
     * Conferma operazione
     * @param id id operazione
     * @param confermaOperazione Conferma operazione
     */
    public confermaOperazioneWithHttpInfo(id: number, confermaOperazione?: models.ConfermaOperazioneVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling confermaOperazione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: confermaOperazione == null ? '' : JSON.stringify(confermaOperazione), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che converte da euro a wkey e viceversa
     * Converte da euro a wkey e viceversa
     */
    public conversioneEuroWkeyWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/info';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di creare un cashback per quella categoria associata a quel negozio
     * Crea un cashback per quella categoria associata a quel negozio
     * @param cashbackNegozioCategoria Il cashbackNegozioCategoria da creare
     */
    public creaCashbackNegozioCategoriaWithHttpInfo(cashbackNegozioCategoria: models.CashbackNegozioCategoriaVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cashback_negozio_categoria';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'cashbackNegozioCategoria' is not null or undefined
        if (cashbackNegozioCategoria === null || cashbackNegozioCategoria === undefined) {
            throw new Error('Required parameter cashbackNegozioCategoria was null or undefined when calling creaCashbackNegozioCategoria.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: cashbackNegozioCategoria == null ? '' : JSON.stringify(cashbackNegozioCategoria), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di creare una categoria
     * Crea una categoria
     * @param categoria La categoria da creare
     */
    public creaCategoriaWithHttpInfo(categoria: models.CategoriaVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/categoria';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'categoria' is not null or undefined
        if (categoria === null || categoria === undefined) {
            throw new Error('Required parameter categoria was null or undefined when calling creaCategoria.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: categoria == null ? '' : JSON.stringify(categoria), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che crea una operazione
     * Crea una operazione
     * @param richiestaOperazione La richiesta operazione
     */
    public creaOperazioneWithHttpInfo(richiestaOperazione?: models.RichiestaOperazioneVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: richiestaOperazione == null ? '' : JSON.stringify(richiestaOperazione), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di creare un Pos
     * Crea un Pos
     * @param pos Il pos da creare
     */
    public creaPosWithHttpInfo(pos: models.PosVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pos' is not null or undefined
        if (pos === null || pos === undefined) {
            throw new Error('Required parameter pos was null or undefined when calling creaPos.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: pos == null ? '' : JSON.stringify(pos), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di creare una promozione
     * Crea una promozione
     * @param promozione La promozione da creare
     */
    public creaPromozioneWithHttpInfo(promozione: models.PromozioneVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/promozione';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'promozione' is not null or undefined
        if (promozione === null || promozione === undefined) {
            throw new Error('Required parameter promozione was null or undefined when calling creaPromozione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: promozione == null ? '' : JSON.stringify(promozione), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che disabilita una carta
     * Disabilita una carta
     * @param id id della carta
     */
    public disabilitaCartaWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/card/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disabilitaCarta.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che disabilita un cliente
     * Disabilita un cliente
     * @param id id del cliente
     */
    public disabilitaClienteWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cliente/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disabilitaCliente.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che disabilita un negozio
     * Disabilita un negozio
     * @param id id del negozio
     */
    public disabilitaNegozioWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disabilitaNegozio.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che disabilita una promozione
     * Disabilita una promozione
     * @param id id della promozione
     */
    public disabilitaPromozioneWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/promozione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disabilitaPromozione.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che disattiva un Pos
     * disattiva un Pos
     * @param id id del pos
     */
    public disattivaPosWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling disattivaPos.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che elimina il cashback di quel negozio per quella categoria
     * elimina il cashback di quel negozio per quella categoria
     * @param id id di CashbackNegozioCategoria
     */
    public eliminaCashbackNegozioCategoriaWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cashback_negozio_categoria/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eliminaCashbackNegozioCategoria.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che elimina una categoria
     * elimina una categoria
     * @param id id della categoria
     */
    public eliminaCategoriaWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/categoria/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eliminaCategoria.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista di carte
     * Ritorna la lista di carte (size &#x3D; 0 lista completa)
     * @param start start del paginatore
     * @param size size del paginatore
     * @param clienteId id del cliente
     * @param codiceCard codice della carta
     */
    public findCarteWithHttpInfo(start?: number, size?: number, clienteId?: number, codiceCard?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/card';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (clienteId !== undefined) {
            queryParameters.set('cliente_id', <any>clienteId);
        }

        if (codiceCard !== undefined) {
            queryParameters.set('codice_card', <any>codiceCard);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista delle categoria con il relativo cashback associate a quel negozio
     * Ritorna la lista delle categoria con il relativo cashback associate a quel negozio
     * @param negozioId id del negozio
     */
    public findCashbackNegozioCategoriaWithHttpInfo(negozioId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cashback_negozio_categoria';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (negozioId !== undefined) {
            queryParameters.set('negozio_id', <any>negozioId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista delle categorie
     * Ritorna la lista delle categorie
     * @param descrizione descrizione della categoria
     */
    public findCategorieWithHttpInfo(descrizione?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/categoria';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (descrizione !== undefined) {
            queryParameters.set('descrizione', <any>descrizione);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista dei clienti
     * Torna la lista dei clienti
     * @param start start del paginatore
     * @param size size del paginatore
     * @param search stringa di ricerca
     */
    public findClienteWithHttpInfo(start?: number, size?: number, search?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cliente';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (search !== undefined) {
            queryParameters.set('search', <any>search);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista dei negozi
     * Ritorna la lista dei negozi (size &#x3D; 0 lista completa)
     * @param start start del paginatore
     * @param size size del paginatore
     * @param search stringa di ricerca
     */
    public findNegoziWithHttpInfo(start?: number, size?: number, search?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (search !== undefined) {
            queryParameters.set('search', <any>search);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista dei pos
     * Ritorna la lista dei pos
     * @param start start del paginatore
     * @param size size del paginatore
     * @param negozioId id del negozio
     * @param attivo stato del pos (&#39;true&#39;,&#39;false&#39; vuoto &#x3D; torna tutti)
     */
    public findPosWithHttpInfo(start?: number, size?: number, negozioId?: number, attivo?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (negozioId !== undefined) {
            queryParameters.set('negozio_id', <any>negozioId);
        }

        if (attivo !== undefined) {
            queryParameters.set('attivo', <any>attivo);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista delle promozioni
     * Ritorna la lista delle promozioni
     * @param negozioId id del negozio. Solo per utente&#x3D;wision. Se negozio_id&#x3D;null torna tutte le promozioni
     */
    public findPromozioniWithHttpInfo(negozioId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/promozione';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (negozioId !== undefined) {
            queryParameters.set('negozio_id', <any>negozioId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna la lista di transazioni
     * Ritorna la lista delle transazioni (size &#x3D; 0 lista completa)
     * @param start start del paginatore
     * @param size size del paginatore
     * @param posId id del pos da cui Ã¨ stata eseguita l&#39;operazione
     * @param negozioId id del negozio che ha eseguito l&#39;operazione
     * @param query stringa di ricerca all&#39;interno della descrizione
     * @param clienteId id del cliente che ha fatto l&#39;acquisto
     */
    public findTransazioniWithHttpInfo(start?: number, size?: number, posId?: number, negozioId?: number, query?: string, clienteId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (posId !== undefined) {
            queryParameters.set('pos_id', <any>posId);
        }

        if (negozioId !== undefined) {
            queryParameters.set('negozio_id', <any>negozioId);
        }

        if (query !== undefined) {
            queryParameters.set('query', <any>query);
        }

        if (clienteId !== undefined) {
            queryParameters.set('cliente_id', <any>clienteId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna i dati di una carta
     * Ritorna i dati di una carta
     * @param id id della carta
     */
    public getCartaByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/card/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCartaById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna un cliente
     * Ritorna un cliente
     * @param id id del cliente
     */
    public getClienteByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cliente/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getClienteById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna i dettagli di una carta e del cliente per effettuare la transazione
     * Ritorna il dettaglio di una carta e del cliente per effettuare la transazione
     * @param codice codice della carta
     */
    public getInfoCartaByCodiceWithHttpInfo(codice: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/infocard/${codice}'
                    .replace('${' + 'codice' + '}', String(codice));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'codice' is not null or undefined
        if (codice === null || codice === undefined) {
            throw new Error('Required parameter codice was null or undefined when calling getInfoCartaByCodice.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna i dettagli di un negozio a partire dall&#39;id
     * Ritorna il dettaglio di un negozio
     * @param id id del negozio
     */
    public getNegozioByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/negozio/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getNegozioById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna un Pos
     * Ritorna un Pos
     * @param id id del pos
     */
    public getPostByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/pos/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPostById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che ritorna una transazione
     * Ritorna una transazione
     * @param id id della transazione
     */
    public getTransazioneByIdWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/operazione/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransazioneById.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di inserire una carta
     * Inserisci una carta
     * @param card La carta da creare
     */
    public inserisciCartaWithHttpInfo(card: models.CardVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/card';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling inserisciCarta.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: card == null ? '' : JSON.stringify(card), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Metodo che permette di inserire un cliente
     * Inserisce un cliente
     * @param cliente Il cliente da inserire
     */
    public inserisciClienteWithHttpInfo(cliente?: models.ClienteVO, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v1/cliente';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('Token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: cliente == null ? '' : JSON.stringify(cliente), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
